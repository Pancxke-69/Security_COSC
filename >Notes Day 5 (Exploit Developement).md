# Buffer Overflow Common Terms
* Heap
* Stack
* Registers
* Instruction Pointer
* Stack Pointer
* Base Pointer
* Function
* Shellcode
# Buffer Overflow Defenses
* Non executable (NX) Stack
* Address Space Layout Randomization (ASLR)
* Data Execution Prevention (DEP)
* Stack Canaries
* Position Independent Excutable (PIE)
# GDB Uses
### Common Commands
```
disass <FUNCTION>     # Disassemble portion of the program
info <...>    # Supply info for specific stack areas
x/256c $<REGISTER>    # Read characters from specific register
break <address>    # Establish a break point
run <<<$(echo "asdfghjlklk")    # Goes into standard in of program. It makes it take an arguement before running the program
info functions    # Lists all the functions
pdisass main    # Lists the main function. (Can do this to any function)
info proc map    # Gets a map of the process
```
# Demo
* Buffer Overflow generator - https://wiremask.eu/tools/buffer-overflow-pattern-generator/
  - Look for "EIP" It should have a specific value from the characters you overflowed it with, copy the hex value determine the overflow amount
* To see the size of the stack, do "info proc map" and note the line with [heap], the line below that has a start addr (this is the start of the stack). Note the end addr of the line that has [stack] in it.
* find /b command:
  - `0xff` is jmp
  - `0xe4` is ESP
```
run <<<$(<./script>)
# Find out the overflow value
# Exit
# Enter a fresh gdb session without peda
env - gdb ./func    # This allows you to do that ^
show env    # Lists variables
unset env <variable>    # This unsets a variable
find /b 0xf7de1000, 0xffffe000, 0xff, 0xe4    # find /b <starting location of stack>, <ending location of the stack>, <jmp>, <esp>
```















